import { defaultFor, round} from '../Utils/methods';
import { globalConfig } from './config';
class ResultsGenerator {
    constructor(data, templates, manual) {
        this.manual = defaultFor(manual, true);
        this.data = data;
        this.templates = templates;
        this.numAutomatic = 1;
        this.helio = false;
        this.cmb = false;
    }
    setHelio(val) {
        this.helio = val;
    }
    setCMB(val) {
        this.cmb = val;
    }
    setNumAutomatic(num) {
        this.numAutomatic = num;
    }
    static getStatistics(results) {
        const totalSpectra = results.length;
        const uses = [];
        for (let i = 0; i < results.length; i++) {
            const d = results[i];
            let use = false;
            for (let j = 0; j < d.length; j++) {
                if (d[j]['name'] == 'QOP' && parseInt(d[j]['value']) > 2) {
                    use = true;
                }
            }
            if (use) {
                uses.push(d);
            }
        }
        let string = "# Redshift quality > 2 for ";
        string += uses.length;
        string += " out of ";
        string += totalSpectra;
        string += " targets, a success rate of  ";
        string += (100.0 * uses.length / totalSpectra).toFixed(1);
        string += "%\n";
        return string;
    }
    getResultsCSV(initials, filename) {
        const results = this.getResultsArray();
        initials = defaultFor(initials, "");
        let string = "# Results generated by " + initials
            + " for file [[" + filename + "]] at " + new Date().toLocaleString() + " (JSON: " + JSON.stringify(new Date()) + ") at version {{" + globalConfig.marzVersion + "}}\n";
        string += ResultsGenerator.getStatistics(results);
        string += "#";
        if (results.length > 0) {
            const spaces = results[0].map(function (x) { return x.name.length; });
            for (let i = 0; i < results.length; i++) {
                const lengths = results[i];
                for (let j = 0; j < lengths.length; j++) {
                    if (lengths[j].value != null && lengths[j].value.length > spaces[j]) {
                        spaces[j] = lengths[j].value.length;
                    }
                }
            }
            for (let i = 0; i < results.length; i++) {
                const res = results[i];
                let first = 0;
                if (i == 0) {
                    for (let k = 0; k < res.length; k++) {
                        string += ((first++ == 0) ? "" : ",  ") + res[k].name.spacePad(spaces[k]);
                    }
                    string += "\n";
                    first = 0;
                }
                for (let j = 0; j < res.length; j++) {
                    string += ((first++ == 0) ? " " : ",  ") + (res[j].value == null ? "" : res[j].value.replace(/,/g, "")).spacePad(spaces[j]);
                }
                string += "\n";
            }
        }
        return string;
    }
    getSpectraWithResults() {
        const result = [];
        for (let i = 0; i < this.data.spectra.length; i++) {
            const spectra = this.data.spectra[i];
            if (spectra.hasRedshiftToBeSaved()) {
                result.push(spectra);
            }
        }
        return result;
    }
    getResultsArray() {
        const result = [];
        for (let i = 0; i < this.data.spectra.length; i++) {
            const spectra = this.data.spectra[i];
            if (spectra.hasRedshiftToBeSaved()) {
                result.push(this.getResultFromSpectra(spectra));
            }
        }
        return result;
    }
    getLocalStorageResult(spectra) {
        const result = {};
        result['z'] = spectra.getFinalRedshift().toFixed(5);
        result['id'] = spectra.getFinalTemplateID() ? spectra.getFinalTemplateID() : "0";
        result['qop'] = "" + spectra.qop;
        result['com'] = spectra.getComment();
        return result;
    }
    getResultFromSpectra(spectra) {
        const result = [];
        result.push({ name: "ID", value: ("" + spectra.id).pad(4) });
        result.push({ name: "Name", value: spectra.name });
        result.push({ name: "RA", value: spectra.ra == null ? null : spectra.ra.toFixed(6) });
        result.push({ name: "DEC", value: spectra.dec == null ? null : spectra.dec.toFixed(6) });
        result.push({ name: "Mag", value: spectra.magnitude == null ? null : spectra.magnitude.toFixed(2) });
        result.push({ name: "Type", value: spectra.type });
        const automatics = spectra.getAutomaticResults();
        if (automatics != null) {
            for (let i = 0; i < this.numAutomatic; i++) {
                const suffix = (i == 0 ? "" : "" + (i + 1));
                if (i >= automatics.length)
                    break;
                result.push({ name: "AutoTID" + suffix, value: automatics[i].templateId });
                result.push({ name: "AutoTN" + suffix, value: this.templates.getNameForTemplate(automatics[i].templateId) });
                result.push({ name: "AutoZ" + suffix, value: automatics[i].z.toFixed(5) });
                result.push({ name: "AutoXCor" + suffix, value: automatics[i].value.toFixed(5) });
            }
        }
        if (this.manual) {
            result.push({ name: "FinTID", value: spectra.getFinalTemplateID() ? spectra.getFinalTemplateID() : "0" });
            result.push({ name: "FinTN", value: this.templates.getNameForTemplate(spectra.getFinalTemplateID()) });
            result.push({ name: "FinZ", value: spectra.getFinalRedshift().toFixed(5) });
        }

        result.push({ name: "QOP", value: "" + spectra.qop });
        result.push({ name: "Comment", value: spectra.getComment().replace(",", " ") });
        if (this.helio) {
            result.push({ name: "HelioCor", value: "" + (spectra.helio == null ? 0 : round(spectra.helio, 7)) });
        }
        if (this.cmb) {
            result.push({ name: "CMBCor", value: "" + (spectra.cmb == null ? 0 : round(spectra.cmb, 7)) });
        }
        return result;
    }
}

export default ResultsGenerator;
